<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[new test]]></title>
    <url>%2F2019%2F04%2F05%2Fnew-test%2F</url>
    <content type="text"><![CDATA[insi gstest]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[test hexo]]></title>
    <url>%2F2019%2F03%2F19%2Ftest-hexo%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2016年BAT公司常见的Web前端面试题整理]]></title>
    <url>%2F2019%2F01%2F21%2F2016%E5%B9%B4BAT%E5%85%AC%E5%8F%B8%E5%B8%B8%E8%A7%81%E7%9A%84Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[2016年BAT公司常见的Web前端面试题整理1.JavaScript是一门什么样的语言，它有哪些特点？ 没有标准答案。 2.JavaScript的数据类型都有什么？ 基本数据类型：String,boolean,Number,Undefined` 引用数据类型：Object(Array,Date,RegExp,Function,Null) 那么问题来了，如何判断某变量是否为数组数据类型？ 方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效 方法二.obj instanceof Array `在某些IE版本中不正确 方法三.方法一二皆有漏洞，在ECMA Script5中定义了新方法Array.isArray(), 保证其兼容性，最好的方法如下： 12345if (typeof Array.isArray === "undefined") &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === "[object Array]" &#125;; &#125; 3.已知ID的Input输入框，希望改变文本框的背景颜色，怎么做？(原生JS) 1document.getElementById("id").style.backgroundColor="red"; 4.希望获取到页面中所有的checkbox怎么做？(原生JS) 12345678var domList = document.getElementsByTagName('input'); var checkBoxList = []; var len = domList.length; //缓存到局部变量 while (len--) &#123;//使用while的效率比for高 if (domList[len].type == 'checkbox') &#123; checkBoxList.push(domList[len]); &#125; &#125; 5.Html事件绑定有几种方式？ 直接在DOM里绑定事件： 这种方式称为原生事件或者属性事件 在JS里通过onclick绑定：xxx.onclick = test Dom标准通过事件添加进行绑定：addEventListener(&quot;click&quot;,test, false) //第三个参数为是否支持事件捕捉 IE事件：attachEvent(&quot;onclick&quot;,test) 那么问题来了，Javascript的事件流模型都有什么？ “事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的 目标事件 “事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播 “DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡 IE事件流：目标事件和事件冒泡 阻止事件冒泡的方式： 1234567stopPropagation():function (ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125;else&#123; ev.cancelBubble=true; &#125;&#125; 阻止事件的默认行为： 1234567preventDefault: function (event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue=false; &#125;&#125; 6.看下列代码，将会输出什么?(变量声明提升) 123var a=1;function a()&#123;&#125;alert(a);//打印1 上面的代码经过变量提升后，等价于下面的代码 123var a;function a()&#123;&#125;a=1;//alert(a); 再看下面的输出结果： 123var a=1;var a=function ()&#123;&#125;alert(a)//打印a函数 此时打印a函数，不会打印1，因为下面是一个函数表达式，跟变量声明一样，只会把var a;提升到最前面，a=function(){}保留，会覆盖前面的a=1;因此打印函数。 此题目，我再百度面试的时候问到过。 7.掌握样式的优先级。 !important &gt; style(内联) &gt; Id(权重100) &gt; class(权重10) &gt; 标签（权重1） 同类别的样式，后面的会覆盖前面的。 百度视频部门一道面试题是这样的： 12345&lt;style&gt; .red&#123;color:red;&#125; .blue&#123;color: blue;&#125;&lt;/style&gt;&lt;p class="blue red"&gt;&lt;/p&gt;//后面的覆盖前面的,显示为blue 8.怎样添加、移除、移动、复制、创建和查找节点 1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() //添加 removeChild() //移除 replaceChild() //替换 insertBefore() //插入 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值 getElementById() //通过元素Id，唯一性 9.用js写一个正则匹配标签中是否包含一个class(百度面试题) 12345function hasClassName (id,name) &#123; var cls=document.getElementById(id).className; var reg=new RegExp("(^|\\s"+name+"($|\\s","g"); return reg.test(cls)&#125; 10.事件循环绑定，输出结果（考察闭包） 12345678var list = document.getElementsByTagName("a") //10个a标签for (let i = 0; i &lt; list.length; i++) &#123; list[i].onclick = function (i) &#123; return function () &#123; alert(i); &#125; &#125;&#125; //都打印10 通过闭包封装后的代码： 123456789var list = document.getElementsByTagName("a") //10个a标签for (let i = 0; i &lt; list.length; i++) &#123; list[i].onclick = (function (i) &#123; return function () &#123; alert(i); &#125; &#125;)(i)&#125; //打印对应的索引 闭包我所知道的两个作用： a.通过闭包可以把局部变量传递出来，就是通过闭包可以访问函数内部的变量，比如下面的代码： 1234567891011function count () &#123; var num = 1; return function () &#123; return num++; &#125;&#125;var countFn = count();countFn();//1countFn();//2countFn();//3countFn();//4 通过闭包就可以访问函数内部的局部变量，并且实现数量累加。 b.使用闭包可以避免空间污染，闭包内部的变量都只能在内部使用，这样有效避免和外部变量的混淆。（个人理解） 11.js数组去重。 12345678910111213var arr = [1, 5, 3, 2, 4, 5, 5, 6, 2, 6, 8]var obj = &#123;&#125;, newArr = [];function delrepeat() &#123; for (let i = 0; i &lt; arr.length; i &lt; j; i++) &#123; if (!obj[arr[i]]) &#123; newArr.push(arr[i]) obj[arr[i]] = arr[i] &#125; &#125;&#125; 12.两个div标签，如何控制标签左边固定，右边自适应，左边div标签的宽度为100px（滴滴面试题） 滴滴面试起初问我，现在有并排的三个Div框，如何实现三个div都自适应，我当时就懵了，这个考察的是display:table的使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;style&gt; html &#123; font-size: 10px; &#125; body &#123; font-size: 1.4rem; &#125; .box &#123; background-color: rgba(200, 200, 200, 0.7); margin: 0 1rem; width: 33.334; padding: 1rem; &#125; .box:nth-child(2) &#123; height: 5rem; background-color: rgba(200, 210, 230, 0.7)1 &#125; .accordant &#123; display: table-row; &#125; .table &#123; width: 100%; display: table &#125; .table .accordant &#123; display: table-row; &#125; .table .accordant .box &#123; display: table-cell; vertical-align: middle; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="table"&gt; &lt;div class="accordant"&gt; &lt;div class="box"&gt; &lt;p&gt;这是一个figure&lt;/p&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;p&gt;这是一个figure&lt;/p&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;p&gt;这是一个figure&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 13.实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制 考察点1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚 考察点2：是否知道如何判断一个变量是什么类型的 考察点3：递归算法的设计 1234567891011121314151617181920212223242526272829//方法一Object.prototype.clone = () =&gt; &#123; var o = this.constructor === Array ? [] : &#123;&#125;; for (const e in this) &#123; o[e] = typeof this[e] === 'object' ? this[e].clone() : this[e] &#125; return o;&#125;//方法二function clone (obj) &#123; var buf; if (obj instanceof Array) &#123; buf = []; var i = obj.length; while (i--) &#123; buf[i]=clone(obj[i]) &#125; return buf; &#125;else if (obj instanceof Object) &#123; buf = &#123;&#125;; for (const key in obj) &#123; buf[key]=clone(obj[key]) &#125; return buf; &#125; else &#123; return obj; &#125;&#125; 14.继承的使用 1234567891011121314151617class Animal &#123; constructor(name) &#123; this.name = name &#125; showName() &#123; console.log(this.name); &#125;&#125;class Dog extends Animal &#123; constructor(name, sex) &#123; super(name); this.sex = 'man' &#125; bark() &#123; console.log('barkiing'); &#125;&#125; 15.请评价以下代码并给出改进意见 1234567891011if (window.addEventListener) &#123; var addListener = function (el, type, listener, userCapture) &#123; el.addEventListener(type, listener, userCapture) &#125;&#125; else if (document.all) &#123; var addListener = function (el, type, listener) &#123; el.attachEvent('on' + type, function () &#123; listener.apply(el) &#125;) &#125;&#125; 评价： 不应该在if和else语句中声明addListener函数，应该提前先声明，定义全局变量； 不需要使用window.addEventListener或document.all来进行检测浏览器，应该使用能力检测； 由于attachEvent在IE中有this指向问题，所以调用它时需要处理一下 改进如下： 试题大全集，程序员收藏了，只发一次！ 123456789function addEvent (elem,type,handler) &#123; if (elem.addEventListener) &#123; elem.addEventListener(type,handler,false) &#125; else if(elem.attachEvent)&#123; elem.attachEvent('on'+type,handler) &#125;else&#123; elem['on'+type]=handler; &#125;&#125; 16.对作用域上下文和this的理解，看下列代码： 123456789var User = &#123; count: 1, getCount() &#123; return this.count; &#125;&#125;;console.log(User.getCount());var func = User.getCount;console.log(func());]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery ajax方法]]></title>
    <url>%2F2018%2F02%2F27%2Fjquery%E4%B8%AD%E7%9A%84ajax%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E6%80%BB%E6%98%AF%E8%AE%B0%E4%B8%8D%E4%BD%8F%EF%BC%8C%E8%BF%99%E9%87%8C%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[jquery中的ajax方法参数总是记不住，这里记录一下。 1.url: 要求为String类型的参数，（默认为当前页地址）发送请求的地址。 2.type:要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。 3.timeout:要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。 4.async:要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。 5.cache:要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。 6.data:要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看 processData选项。对象必须为key/value格式，例如{foo1:&quot;bar1&quot;,foo2:&quot;bar2&quot;}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[&quot;bar1&quot;,&quot;bar2&quot;]}转换为&amp;foo=bar1&amp;foo=bar2。 7.dataType:要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：xml：返回XML文档，可用JQuery处理。html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。json：返回JSON数据。jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。text：返回纯文本字符串。 8.beforeSend：要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。 123function(XMLHttpRequest) &#123; this; //调用本次ajax请求时传递的options参数 &#125; 9.complete：要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。 123function(XMLHttpRequest, textStatus) &#123; this; //调用本次ajax请求时传递的options参数 &#125; 10.success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。​ (1)由服务器返回，并根据dataType参数进行处理后的数据。​ (2)描述状态的字符串。 1234function(data, textStatus)&#123; //data可能是xmlDoc、jsonObj、html、text等等 this; //调用本次ajax请求时传递的options参数&#125; 11.error:要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下： 1234function(XMLHttpRequest, textStatus, errorThrown)&#123; //通常情况下textStatus和errorThrown只有其中一个包含信息 this; //调用本次ajax请求时传递的options参数&#125; 12.contentType：要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded”。该默认值适合大多数应用场合。 13.dataFilter：要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。​ 1234function(data, type)&#123; //返回处理后的数据 return data; &#125; 14.dataFilter：要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。 1234function(data, type) &#123; //返回处理后的数据 return data; &#125; 15.global：要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。 16.ifModified：要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。 17.jsonp：要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在”callback=?”这种GET或POST请求中URL参数里的”callback”部分，例如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad=?”传给服务器。 18.username：要求为String类型的参数，用于响应HTTP访问认证请求的用户名。 19.password：要求为String类型的参数，用于响应HTTP访问认证请求的密码。 20.processData：要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型”application/x-www-form-urlencoded”。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。 21.scriptCharset：要求为String类型的参数，只有当请求时dataType为”jsonp”或者”script”，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。 案例代码： 1234567891011121314151617181920$(function()&#123; $('#send').click(function()&#123; $.ajax(&#123; type: "GET", url: "test.json", data: &#123;username:$("#username").val(), content:$("#content").val()&#125;, dataType: "json", success: function(data)&#123; $('#resText').empty(); //清空resText里面的所有内容 var html = ''; $.each(data, function(commentIndex, comment)&#123; html += '&lt;div class="comment"&gt;&lt;h6&gt;' + comment['username'] \+ ':&lt;/h6&gt;&lt;p class="para"' + comment['content'] \+ '&lt;/p&gt;&lt;/div&gt;'; &#125;); $('#resText').html(html); &#125; &#125;); &#125;);&#125;); $.ajax验证登录： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 &lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt; function IbtnEnter_onclick() &#123; checklogin(); return false; &#125; function checklogin() &#123; if ($(&quot;#TxtUserName&quot;).val() == &quot;&quot;) &#123; alert(&quot;用户名不能为空！&quot;); $(&quot;#TxtUserName&quot;).focus(); return false; &#125; if ($(&quot;#TxtPassword&quot;).val() == &quot;&quot;) &#123; alert(&quot;密码不能为空！&quot;); $(&quot;#TxtPassword&quot;).focus(); return false; &#125; $.ajax(&#123; type: &quot;POST&quot;, url: &quot;ajax/Handler.ashx?M=&quot; + Math.random(), data: &quot;username=&quot; + $(&quot;#TxtUserName&quot;).val().toString() + &quot;&amp;pwd=&quot; + $(&quot;#TxtPassword&quot;).val().toString(), success: function (data) &#123; if (data == &quot;1&quot;) &#123; location.href = &quot;index.aspx&quot;; return true; &#125; else &#123; alert(&quot;请确认您输入的用户名或密码输入是否正确！&quot;); $(&quot;#TxtUserName&quot;).val(&quot;&quot;); $(&quot;#TxtPassword&quot;).val(&quot;&quot;); $(&quot;#TxtUserName&quot;).focus(); return false; &#125; &#125; &#125;) &#125; &lt;/script&gt;一般处理程序&lt;%@ WebHandler Language=&quot;C#&quot; Class=&quot;Handler&quot; %&gt;using System;using System.Web;using System.Data.SqlClient;using System.Web.SessionState;//继承接口IReadOnlySessionState需要引入的命名空间public class Handler : IHttpHandler, IRequiresSessionState&#123; SqlHelper helper = new SqlHelper(); public void ProcessRequest(HttpContext context) &#123; context.Response.ContentType = &quot;text/plain&quot;; string username = context.Request.Params[&quot;username&quot;].ToString().Trim(); string pwd = context.Request.Params[&quot;pwd&quot;].ToString().Trim(); if (username != &quot;&quot; &amp;&amp; pwd != &quot;&quot;) &#123; string sql = @&quot;SELECT * FROM [USER] WHERE USERNAME=&apos;&quot;+username+&quot;&apos; AND PASSWORD=&apos;&quot;+pwd+&quot;&apos; &quot;; if (!helper.Exists(sql)) &#123; context.Response.Write(&quot;0&quot;); &#125; else &#123; SqlDataReader reader = helper.ExecuteReader(sql); while (reader.Read()) &#123; context.Response.Write(&quot;1&quot;); context.Session[&quot;username&quot;] = username.ToString().Trim(); context.Session[&quot;pwd&quot;] = pwd.ToString().Trim(); &#125; &#125; &#125; &#125; public bool IsReusable &#123; get &#123; return false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>前端,js</category>
      </categories>
      <tags>
        <tag>Programming</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jrebel插件]]></title>
    <url>%2F2017%2F11%2F30%2FJrebel%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Jrebel插件标签： 插件 IntelliJ IDEA 的 Java 热部署插件 JRebel 安装及使用JRebel 介绍在 Java Web 开发中， 一般更新了 Java 文件后要手动重启 Tomcat 服务器， 才能生效， 浪费不少生命啊， 自从有了 JRebel 这神器的出现， 不论是更新 class 类还是更新 Spring 配置文件都能做到立马生效，大大提高开发效率。 JRebel 安装 JRebel 的安装方法有两种， 一种是直接在 Tomcat 启动参数上面加上 JRebel 的参数， 另外一种是以插件的形式装到 IntelliJ IDEA 上， 比较推荐后者。 第一种安装方法：在 Tomcat 启动参数上加参数首先先介绍第一种安装方法， 先在硬盘某个位置把 JRebel 解压出来先配置一下本地tomcat 默认显示如图 几个关键的地方需要注意的， 就是首先要选择Deployment 这个选项卡 选择自己的项目， 建议选择带 exploded， 这个相当于改 Tomcat 的 CATALINA_HOME， 效率比较高选择好后， 删掉默认的Make， 提高效率 接下来返回 Server 选项卡， 会发现多了一项 On frame deactivation， 如果你刚才没有配置 Deployment 选项卡的话的这项是不会出现的 按如图所示的来配置， 特别需要注意的是 On &#39;Update&#39; action 和On frame deactivation这两项目一定要选择 Update classes and resources， 否则类修改热部署不生效， 或者第三方模版框架例如 Freemarker 热部署不生效 接下来就是很关键的需要引入 JRebel 的地方了， 在 VM options 的最右边有个箭头， 点进去Windows 输入:1-agentpath:D:/dev_env/jrebel/jrebel_running/lib/jrebel64.dll 第二种安装方法：使用 IntelliJ IDEA 插件下载安装jrebel 然后注册 Jrebel 激活方法 确保你可也访问国外网站（www.facebook.com）,并确保你有一个facebook账号或者Twitter账号(没有的话注册一个) 访问 https://my.jrebel.com/ 选择自己的facebook账号登录完成后 3 将激活码复制到Intellij Idea Rrebel激活4 查看当前Jrebel状态，绿色图标表示激活状态 激活完毕 ### 运行在原来运行项目的按钮边上会多出两个绿色的按钮， 如图， 前面那个是 Run， 后面那个是Debug 配置 Tomcat 的方法和直接上面说的直接调用配置方法一样， 同样需要注意的是On &#39;Update&#39; action和 On frame deactivation这两项目一定要选择Update classes and resources， 唯一不同的是VM options 这项不需要填， 放空就好 接下来直接启动项目， 一般选择后面那个Debug 按钮看到 Log 有 JRebel 输出的版本信息， 没有报错就是表示成功执行了 配置springboot先安装jrebel,配置好后: Idea中ctrl+alt+shift+/弹出 进入registry 进入如下界面 将compiler.automake.allow.when.app.running 选中,退出该界面 在项目的src/resources文件夹右键,弹出菜单最下边JReble&gt;rebel.xml 打开刚刚生成的rebel.xml文件,将classpath dir修改到你项目的build文件夹 在启动类中右键,使用Jrebel（Debug | run）进行启动配置该项目 启动后呢,修改了代码,直接编译Build&gt;build project,刷新一下网页就可以看到效果了,尽情的享受不重启服务器带来的快感吧！]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA设置]]></title>
    <url>%2F2017%2F05%2F08%2FIDEA%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[idea标签： 设置 先来看一些idea文件目录 IntelliJ IDEA 的安装目录并不复杂，上图为最常改动的 bin 目录，经常会改动的文件或是必须介绍就是如图红色框中的几个。 idea.exe 文件是 IntelliJ IDEA 32 位的可行执行文件，IntelliJ IDEA 安装完默认发送到桌面的也就是这个执行文件的快捷方式。 idea.exe.vmoptions 文件是 IntelliJ IDEA 32 位的可执行文件的 VM 配置文件，具体配置修改会下面进行专门讲解。 idea64.exe 文件是 IntelliJ IDEA 64 位的可行执行文件，要求必须电脑上装有 JDK 64 位版本。64 位的系统也是建议使用该文件。 idea64.exe.vmoptions 文件是 IntelliJ IDEA 64 位的可执行文件的 VM 配置文件，具体配置修改会下面进行专门讲解。 idea.properties 文件是 IntelliJ IDEA 的一些属性配置文件，具体配置修改会下面进行专门讲解。 不管你使用的是哪个操作系统，IntelliJ IDEA 的设置目录命名是统一的、有规律：大家没设置的话应该是C:\Users\你的用户名\.IntelliJIdea2017.2的设置目录，其他版本道理一样。 在三大主流的操作系统上该文件夹都在当前用户的 Home 目录，Windows 上即%userprofile%，Linux 和 Mac 上即 ~ 对于这个设置目录有一个特性，就是你删除掉整个目录之后，重新启动 IntelliJ IDEA 会再自动帮你再生成一个全新的默认配置，所以很多时候如果你把 IntelliJ IDEA 配置改坏了，没关系，删掉该目录，一切都会还原到默认，我是很建议新人可以多自己摸索 IntelliJ IDEA 的配置，多几次还原，有助于加深对 IntelliJ IDEA 的了解。 config 目录是 IntelliJ IDEA 个性化化配置目录，或者说是整个 IDE 设置目录。也是我个人认为最重要的目录，没有之一，如果你还记得安装篇的介绍的时候，安装新版本的 IntelliJ IDEA 会自动扫描硬盘上的旧配置目录，指的就是该目录。这个目录主要记录了：IDE 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、Project 的 tasks 记录等等个性化的设置。 system 目录是 IntelliJ IDEA 系统文件目录，是 IntelliJ IDEA 与开发项目一个桥梁目录，里面主要有：缓存、索引、容器文件输出等等，虽然不是最重要目录，但是也是最不可或缺目录之一。 上图是 64 位可执行文件的 JVM 配置文件内容，如果你是 32 位的系统你应该修改的是 idea.exe.vmoptions 文件里面的内容，但是由于 32 位系统内存一般都是 2G 左右的，所以也没有多大空间可以调整，所以一般无需调整的。 修改的原则主要是根据自己机器的内存情况来判断的，我个人是建议 8G 以下的机子或是静态页面开发者都是无需修改的。如果你是开发大型项目、Java 项目或是 Android 项目，并且内存大于 8G，建议进行修改，常修改的就是下面 4 个参数，我这里主要以我的机子会例进行建议，每个人机子情况不一，这里也只是做一个引子，最好的调整方式是你可以根据 jconsole 这类工具进行观察后个性化调整。 强烈推荐使用 IDEA 自带菜单中的Help -&gt; Edit Custom VM Options 来进行个性化配置，而不是直接修改安装目录中的该文件！ -Xms128m，16 G 内存的机器可尝试设置为 -Xms512m -Xmx750m，16 G 内存的机器可尝试设置为 -Xmx1500m -XX:MaxPermSize=350m，16G 内存的机器可尝试设置为 -XX:MaxPermSize=500m -XX:ReservedCodeCacheSize=225m，16G 内存的机器可尝试设置为-XX:ReservedCodeCacheSize=500m 上图是 IntelliJ IDEA 一些属性配置，没有 32 位和 64 位之分，修改原则主要根据个人对 IntelliJ IDEA 的个性化配置情况来分析。强烈推荐在阅读了安装目录中的带注释的配置文件后，使用 IDEA 自带菜单中的 Help -&gt; Edit Custom Properties 来进行个性化配置！常修改的就是下面 4 个参数： *idea.config.path=${user.home}/.IntelliJIdea/config，该属性主要用于指向 IntelliJ IDEA 的个性化配置目录，默认是被注释，打开注释之后才算启用该属性，这里需要特别注意的是斜杠方向，这里用的是正斜杠。 idea.system.path=${user.home}/.IntelliJIdea/system，该属性主要用于指向 IntelliJ IDEA 的系统文件目录，默认是被注释，打开注释之后才算启用该属性，这里需要特别注意的是斜杠方向，这里用的是正斜杠。如果你的项目很多，则该目录会很大，如果你的 C 盘空间不够的时候，还是建议把该目录转移到其他盘符下。 idea.max.intellisense.filesize=2500，该属性主要用于提高在编辑大文件时候的代码帮助。IntelliJ IDEA 在编辑大文件的时候还是很容易卡顿的。 idea.cycle.buffer.size=1024，该属性主要用于控制控制台输出缓存。有遇到一些项目开启很多输出，控制台很快就被刷满了没办法再自动输出后面内容，这种项目建议增大该值或是直接禁用掉，禁用语句 idea.cycle.buffer.size=disabled。]]></content>
      <categories>
        <category>Configuration</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 知识总结]]></title>
    <url>%2F2017%2F02%2F27%2Fjquery%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[标签： 编程,前端 超全面！这可能是最全面的 jQuery 知识总结个人建议：学习 jQuery 前先掌握基本的 JavaScrpit 语法，特别是对函数要掌握，jQuery 基本上是使用函数。 jQuery 简介 jQuery 是一个轻量级 JavaScript 库 jQuery 库位于一个 JavaScript 文件中，其中包含了所有的 jQuery 函数，需要通过 标签引入 jQuery 库才能进行使用 jQuery 库的三种引入来源 本地引入 共有两个版本的 jQuery 可供下载 http://jQuery.com：一份是精简过的，另一份是未压缩的（供调试或阅读） 从 Google 加载 CDN jQuery 核心文件（ 版本可更换 ） 12&gt; src = http://ajax.googleapis.com/ajax/libs/jquery/1.4.0/jquery.min.js&gt; 从 Microsoft 加载 CDN jQuery 核心文件（ 版本可更换 ） 12&gt; src = http://ajax.microsoft.com/ajax/jquery/jquery-1.4.min.js&gt; jQuery语法基础语法：$(selector).action() 美元符号（$）定义 jQuery 选择符（selector）“ 查询 ” 和 “ 查找 ” HTML 元素 jQuery 的 action() 执行对元素的操作 文档就绪函数 文档就绪函数，用于在页面加载成功后执行的指定代码 如果在文档没有完全加载之前就运行函数，操作可能失败 通常该函数用于替换 window.onload 事件，文档就绪函数的执行效率更高 1$(document).ready(function()&#123; code block&#125;); 可以简写为: 1$(function()&#123; code block&#125;); jQuery 使用 $ 符号作为 jQuery 的简写 jQuery 标识符 使用 jQuery 全名 1jQuery(document).ready(function()&#123;jQuery("button").click(function()&#123; code block&#125;);&#125;); 使用 jQuery 简写 1$(function()&#123; $(&quot;button&quot;).click(function()&#123; code block &#125;);&#125;); 自定义 jQuery 别名 1var jq = $.noConflict();jq(function()&#123; jq(&quot;button&quot;).click(function()&#123; code block &#125;);&#125;); 注：因为 javascrpit 某些框架中也使用 $ 作为简写( 就像 jQuery )，noConflict() 方法是为了解决 javascrpit 框架之间符号冲突而定义的方法，它会释放 $ 标识符的控制，这样其他脚本也可以使用这个符号 jQuery 选择器jQuery 元素选择器和属性选择器允许您通过标签名、属性名或内容对 HTML 元素进行选择 jQuery 元素选择器 jQuery 使用 CSS 选择器来选取 HTML 元素 $(this) 当前 HTML 元素 $(“p”) 选取 元素 $(“p.intro”) 选取所有 class=”intro” 的 元素 $(“p#demo”) 选取所有 id=”demo” 的 元素 $(“div#intro .head”) 选取 id=”intro” 的 元素中的所有 class=”head” 的元素 jQuery 属性选择器 jQuery 使用 XPath 表达式来选择带有给定属性的元素 $(“[href]”) 选取所有带有href 属性的元素 $(“[href=’#’]”) 选取所有带有 href 值等于”#” 的元素 $(“[href!=’#’]”) 选取所有带有 href 值不等于 “#” 的元素 $(“[href$=’.jpg’]”) 选取所有 href 值以 “.jpg” 结尾的元素 jQuery CSS 选择器 jQuery CSS 选择器可用于改变 HTML 元素的 CSS 属性 把所有 p 元素的背景颜色更改为红色：$(&quot;p&quot;).css(&quot;background-color&quot;,&quot;red&quot;) jQuery 事件 jQuery 事件处理方法是 jQuery 中的核心函数 事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。术语由事件“触发”（或“激发”）经常会被使用 例子：按钮的点击事件被触发时会调用一个函数 $(&quot;button&quot;).click(function() {..some code... } ) 常用事件函数 $(document).ready(function) 将函数绑定到文档的就绪事件（当文档完成加载时） $(selector).click(function) 触发或将函数绑定到被选元素的点击事件 $(selector).change(function) 触发、或将函数绑定到指定元素的 change 事件 $(selector).dblclick(function) 触发或将函数绑定到被选元素的双击事件 $(selector).focus(function) 触发或将函数绑定到被选元素的获得焦点事件 $(selector).mouseover(function) 触发或将函数绑定到被选元素的鼠标悬停事件 jQuery 效果效果通常绑定在某在事件上，例如通过点击按钮产生隐藏效果 常见的用于效果的函数 1.隐藏、显示、切换 1- 隐藏 `$(selector).hide(speed,callback)` ： `$(&quot;p&quot;).hide();`- 显示`$(selector).show(speed,callback)` ： `$(&quot;p&quot;).show(1000);`- 切换隐藏/显示`$(selector).toggle(speed,callback)` ： `$(&quot;p&quot;).toggle();` speed 和 callback 都是可选参数 speed 参数规定显示/隐藏的速度，可选值为：”slow”、”fast” 或毫秒值 callback 参数是显示/隐藏完成后所执行的函数名称 2.淡入、淡出 1- 淡入 `$(selector).fadeIn(speed,callback)` ： `$(&quot;#div1&quot;).fadeIn(&quot;slow&quot;);`- 淡出 `$(selector).fadeOut(speed,callback)` ： `$(&quot;#div3&quot;).fadeOut(3000);`- 切换淡入/淡出 `$(selector).fadeToggle(speed,callback)` ： ` $(&quot;#div1&quot;).fadeToggle();`- 渐变为特定透明度 `$(selector).fadeTo(speed,opacity,callback)` ：`$(&quot;#div2&quot;).fadeTo(&quot;slow&quot;,0.4);` speed 和 callback 都是可选参数，opacity 为必需参数 speed 参数规定淡入/淡出的速度，可选值为：”slow”、”fast” 或毫秒值 callback 参数是显示/隐藏完成后所执行的函数名称 opacity 参数将淡入淡出效果设置为给定的不透明度（值介于 0 与 1 之间) 3.滑动 1- 向下滑动 `$(selector).slideDown(speed,callback)` ： `$(&quot;#panel&quot;).slideDown();`- 向上滑动 `$(selector).slideUp(speed,callback)` : `$(&quot;#panel&quot;).slideUp();`- 切换向上滑动/向下滑动 `slideToggle()` : `$(&quot;#panel&quot;).slideToggle();` speed 和 callback 都是可选参数 speed 参数规定向上滑动/向下滑动的速度，可选值为：”slow”、”fast” 或毫秒值 callback 参数是向上滑动/向下滑动完成后所执行的函数名称 4.动画 1- 自定义动画 `$(selector).animate(&#123;params&#125;,speed,callback)` params 是必需参数， speed 和 callback 是可选参数 params 参数定义形成动画的 CSS 属性 speed 参数规定效果的时长，可选值为：”slow”、”fast” 或毫秒值 callback 参数是动画完成后所执行的函数名称 注： 默认地，所有 HTML 元素都有一个静态位置，且无法移动，如需对位置进行操作，要记得首先把元素的 CSS position 属性设置为 relative、fixed 或 absolute！ 1- 停止动画 ·`$(selector).stop(stopAll,goToEnd);` stopAll 和 goToEnd 都是可选参数 stopAll 参数规定是否应该清除动画队列。默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行 goToEnd 参数规定是否立即完成当前动画。默认是 false。 默认地，stop() 会清除在被选元素上指定的当前动画 实例 使用绝对值 1$(&quot;div&quot;).animate(&#123; left:&apos;250px&apos;, opacity:&apos;0.5&apos;, height:&apos;150px&apos;, width:&apos;150px&apos; &#125;); 使用相对值 1$(&quot;button&quot;).click(function()&#123; $(&quot;div&quot;).animate(&#123; left:&apos;250px&apos;, height:&apos;+=150px&apos;, width:&apos;+=150px&apos; &#125;);&#125;); 使用队列功能 ( 逐一进行 animate 调用 ) 1$(&quot;button&quot;).click(function()&#123; var div=$(&quot;div&quot;); div.animate(&#123;height:&apos;300px&apos;,opacity:&apos;0.4&apos;&#125;,&quot;slow&quot;); div.animate(&#123;width:&apos;300px&apos;,opacity:&apos;0.8&apos;&#125;,&quot;slow&quot;); div.animate(&#123;height:&apos;100px&apos;,opacity:&apos;0.4&apos;&#125;,&quot;slow&quot;); div.animate(&#123;width:&apos;100px&apos;,opacity:&apos;0.8&apos;&#125;,&quot;slow&quot;);&#125;); 5.方法连接 允许我们在相同的元素上运行多条 jQuery 命令，一条接着另一条，这样的话，浏览器就不必多次查找相同的元素。如需链接一个动作，您只需简单地把该动作追加到之前的动作上 例如： 把 css(), slideUp() 和 slideDown() 链接在一起。”p1” 元素首先会变为红色，然后向上滑动，然后向下滑动 $(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;).slideUp(2000).slideDown(2000); jQuery 操作 HTML 元素和属性对内容操作 1.获取内容 1- `$(selector).text();` 设置或返回所选元素的文本内容- `$(selector).html();` 设置或返回所选元素的内容（包括 HTML 标记）- `$(selector).val();` 设置或返回表单字段的值 2.设置内容 1- `$(selector).text(string);` 设置所选元素的文本内容- `$(selector).val(string);` 设置所选元素的内容（包括 HTML 标记）- `$(selector).html(string);` 设置表单字段的值 3.回调函数 i：被选元素列表中当前元素的下标 origText：原始（旧的）值 res：以函数新值返回您希望使用的字符串 1- `$(selector).text(function(i,origText)&#123;return res;&#125;);` 设置或返回所选元素的文本内容- `$(selector).val(function(i,origText)&#123;return res;&#125;);` 设置或返回所选元素的内容（包括 HTML 标记）- `$(selector).html(function(i,origText)&#123;return res;&#125;);` 设置或返回表单字段的值 对属性操作 1.获取属性 1- `$(selector).attr(&quot;attribute&quot;);` 获取指定元素的所选属性 2.设置属性 1- `$(selector).attr(&quot;attribute&quot;,&quot;value&quot;);` 设置所选属性的值- `$(selector).attr(&#123;&quot;attribute1&quot;:&quot;value1&quot;, &quot;attribute2&quot;:&quot;value2&quot;&#125;);` 同时设置多个属性的值 3.attr() 的回调函数 i ： 被选元素列表中当前元素的下标 origValue : 原始（旧的）值 res ： 以函数新值返回您希望使用的字符串 1- `$(selector).attr(&quot;attribute&quot;,function(i,origValue)&#123;return res&#125;);` 对元素/内容操作 与前面的 对内容操作 不同的是：上面的三个方法会将原来的值覆盖，而这里的方法是在原值基础上进行修改 1.添加 参数可以是多个，如果多个含有 html 的内容，则相当于增加了多个 html 元素 1- `$(selector).append(&quot;text&quot;);` 在被选元素的结尾插入内容- `$(selector).prepend(&quot;text&quot;);` 在被选元素的开头插入内容- `$(selector).prepend(&quot;text&quot;);` 在被选元素之后插入内容- `$(selector).before(&quot;text&quot;);` 在被选元素之前插入内容 2.删除 1- `$(selector).remove();` 删除被选元素（及其子元素）- `$(selector).empty();` 从被选元素中删除子元素- `$(selector).remove(selector);` 删除指定选择器的元素 对 CSS 元素操作 前三种方法是针对已经写好的样式 1- `$(selector).addClass(&quot;className1 className2&quot;);` 向被选元素添加一个或多个类- `$(selector).removeClass(&quot;className1 className2&quot;);` 从被选元素删除一个或多个类- `$(selector).toggleClass(&quot;className&quot;);` 对被选元素进行添加/删除类的切换操作- `$(selector).css();`返回样式属性- `$(selector).css(&quot;attribute&quot;,&quot;value&quot;);`设置单个样式属性- `$(selector).css(&#123;&quot;propertyname&quot;:&quot;value&quot;,&quot;propertyname&quot;:&quot;value&quot;,...&#125;);`设置多个样式属性 对尺寸操作 注意参数，中间四种没有没有参数，不能进行设置 1- `$(selector).width(&quot;text&quot;);` 设置或返回元素的宽度（不包括内边距、边框或外边距）- `$(selector).height(&quot;text&quot;);` 设置或返回元素的高度（不包括内边距、边框或外边距）- `$(selector).innerWidth();`返回元素的宽度（包括内边距）- `$(selector).innerHeight(&quot;);`返回元素的高度（包括内边距）- `$(selector).outerWidth();`返回元素的宽度（包括内边距和边框）- `$(selector).outerHeight();` 返回元素的高度（包括内边距和边框）- `$(selector).outerWidth(true);`返回元素的宽度（包括内边距、边框和外边距）- `$(selector).outerHeight(true);` 返回元素的高度（包括内边距、边框和外边距） jQuery 遍历 DOM祖先 向上遍历 DOM 树 1- `$(selector).parent();` 返回被选元素的直接父元素，该方法只会向上一级对 DOM 树进行遍历- `$(selector).parents();` 返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (&lt;html&gt;)- `$(selector).parents(selector);` 返回经过过滤的所有祖先元素，它一路向上直到文档的根元素 (&lt;html&gt;)- `$(selector).parentsUntil() ;`返回介于两个给定元素之间的所有祖先元素 祖先 向下遍历 DOM 树，以查找元素的后代 1- `$(selector).children();` 返回被选元素的所有直接子元素，该方法只会向下一级对 DOM 树进行遍历- `$(selector).children(selector);` 返回被选元素的经过过滤的子元素，该方法只会向下一级对 DOM 树进行遍历- `$(selector).find(&quot;selector&quot;);` 返回被选元素的后代元素，一路向下直到最后一个后代(此方法必须有参数，如果是全部则为 &quot;*&quot; ) 同胞 DOM 树中遍历元素的同胞元素 1- `$(selector).siblings(selector);` 返回被选元素的所有同胞元素（selector可选）- `$(selector).next();` 返回被选元素的下一个同胞元素- `$(selector).nextAll();` 返回被选元素的所有跟随的同胞元素- `$(selector).nextUntil(selecotr);` 返回介于两个给定参数之间的所有跟随的同胞元素- prev(), prevAll() 以及 prevUntil() 方法的工作方式与上面的方法类似，只不过方向相反而已：它们返回的是前面的同胞元素（在 DOM 树中沿着同胞元素向后遍历，而不是向前） 过滤 允许您基于其在一组元素中的位置来选择一个特定的元素 1- `$(selector).first();` 返回被选元素的首个元素- `$(selector).last();` 返回被选元素的最后一个元素- `$(selector).eq();` 返回被选元素中带有指定索引号的元素（索引号从 0 开始）- `$(selector).filter(selector);` 不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回- `$(selector).not(selector);` not() 方法与 filter() 相反，返回不匹配标准的所有元素 jQuery AjaxAJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML） 简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示 load 方法 1- `$(selector).load(URL,data,callback);`方法从服务器加载数据，并把返回的数据放入被选元素中 必需的 URL 参数规定您希望加载的 URL。 可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。 可选的 callback 参数是 load() 方法完成后所执行的函数名称 callback 回调函数 $(selector).load(URL,data,function(responseTxt,statusTxt,xhr){}); responseTxt - 包含调用成功时的结果内容 statusTXT - 包含调用的状态 xhr - 包含 XMLHttpRequest 对象 responseTxt - 包含调用成功时的结果内容 statusTXT - 包含调用的状态 xhr - 包含 XMLHttpRequest 对象 get/post 方法 必需的 URL 参数规定您希望请求的 URL 可选的 callback 参数是请求成功后所执行的函数名 1- `$.get(URL,callback);`通过 HTTP GET 请求从服务器上请求数据 GET - 从指定的资源请求数据 GET 基本上用于从服务器获得（取回）数据。注释：GET 方法可能返回缓存数据 1- `$.post(URL,data,callback);`通过 HTTP POST 请求从服务器上请求数据 data 是要提交给服务器的数据，如果数据有多个，使用 json 格式 POST - 向指定的资源提交要处理的数据 POST 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据 回调函数 data : 存有被请求页面的内容 status : 存有请求的状态( success/fail ) 1function(data,status)&#123; alert(&quot;Data: &quot; + data + &quot; Status: &quot; + status); &#125;); 注意： ajax 不能访问本地文件，需要解决跨域访问的问题]]></content>
      <categories>
        <category>前端,js</category>
      </categories>
      <tags>
        <tag>Config</tag>
        <tag>Programming</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
